#include <iostream>
#include <tuple>
#include <memory>
#include <string>

class Apparatus {
private:
    std::string name;
public:
    Apparatus(const std::string& n) : name(n) {}
    std::string getName() const { return name; }
};

// Класс потока с умными указателями на аппараты
class Stream {
private:
    double concentration;
    double volume;
    std::shared_ptr<Apparatus> fromApparatus; // аппарат из которого вытекает поток
    std::shared_ptr<Apparatus> toApparatus;   // аппарат в который втекает поток

public:
    Stream(double conc, double vol) : concentration(conc), volume(vol) {}

    // Геттеры и сеттеры для концентрации и объема
    double getConcentration() const { return concentration; }
    void setConcentration(double conc) { concentration = conc; }

    double getVolume() const { return volume; }
    void setVolume(double vol) { volume = vol; }

    // Геттеры и сеттеры для аппаратуры
    std::shared_ptr<Apparatus> getFromApparatus() const { return fromApparatus; }
    void setFromApparatus(std::shared_ptr<Apparatus> app) { fromApparatus = app; }

    std::shared_ptr<Apparatus> getToApparatus() const { return toApparatus; }
    void setToApparatus(std::shared_ptr<Apparatus> app) { toApparatus = app; }
};

// Функция моделирования реактора в новом формате
std::tuple<Stream, Stream> complexReactor(const Stream& input1, const Stream& input2,
                                         std::shared_ptr<Apparatus> reactorApparatus) {
    double totalVolume = input1.getVolume() + input2.getVolume();
    double mixedConcentration = (input1.getConcentration() * input1.getVolume() + input2.getConcentration() * input2.getVolume()) / totalVolume;
    double reactedConcentration = mixedConcentration * 0.7;

    Stream output1(reactedConcentration, totalVolume * 0.5);
    Stream output2(reactedConcentration, totalVolume * 0.5);

    // Установка информации об аппаратах для выходных потоков
    output1.setFromApparatus(reactorApparatus);
    output2.setFromApparatus(reactorApparatus);

    // Для примера: выходы направляются в какой-то следующий аппарат (nullptr если нет)
    output1.setToApparatus(nullptr);
    output2.setToApparatus(nullptr);

    return std::make_tuple(output1, output2);
}

int main() {
    auto apparatus1 = std::make_shared<Apparatus>("Input Apparatus 1");
    auto apparatus2 = std::make_shared<Apparatus>("Input Apparatus 2");
    auto reactor = std::make_shared<Apparatus>("Complex Reactor");

    Stream input1(2.0, 10.0);
    input1.setFromApparatus(apparatus1);
    input1.setToApparatus(reactor);

    Stream input2(5.0, 5.0);
    input2.setFromApparatus(apparatus2);
    input2.setToApparatus(reactor);

    auto [output1, output2] = complexReactor(input1, input2, reactor);

    std::cout << "Output 1: concentration = " << output1.getConcentration()
              << ", volume = " << output1.getVolume()
              << ", from = " << (output1.getFromApparatus() ? output1.getFromApparatus()->getName() : "none")
              << ", to = " << (output1.getToApparatus() ? output1.getToApparatus()->getName() : "none") << "\n";

    std::cout << "Output 2: concentration = " << output2.getConcentration()
              << ", volume = " << output2.getVolume()
              << ", from = " << (output2.getFromApparatus() ? output2.getFromApparatus()->getName() : "none")
              << ", to = " << (output2.getToApparatus() ? output2.getToApparatus()->getName() : "none") << "\n";

    return 0;
}
